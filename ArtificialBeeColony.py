import random

from Scheduler import Scheduler


class ABC_Scheduler:
    """
    A class representing the ABC algorithm for task scheduling.
    """

    def __init__(self, n_tasks, n_employed_bees, n_onlooker_bees, n_scout_bees, n_iters):
        self.n_tasks = n_tasks
        self.n_employed_bees = n_employed_bees
        self.n_onlooker_bees = n_onlooker_bees
        self.n_scout_bees = n_scout_bees
        self.n_iters = n_iters

    def initialize_population(self, num_tasks):
        """
        Initializes the population with random task orders.

        Args:
            num_tasks (int): Number of tasks.

        Returns:
            list: A list of task orders (chromosomes).
        """
        population = []
        for i in range(self.pop_size):
            chromosome = [j for j in range(num_tasks)]
            random.shuffle(chromosome)
            population.append(chromosome)
        return population

    def calculate_cost(self, schedule, task_list):
        """ Calculate the cost of a schedule.

        Args:
            schedule (list): The schedule to evaluate, represented as a list of task IDs in the order they should be executed.
            task_list (list): A list of tasks, where each task is represented as a tuple (p, d), where p is the processing time and d is the deadline.

        Returns:
            The cost of the schedule, calculated as the sum of the lateness costs of each task.
        """
        cost = 0
        time = 0
        for task_id in schedule:
            p, d = task_list[task_id]
            time += p
            if time > d:
                cost += time - d
        return cost

    def crossover(self, schedule, task_list):
        """ Generate a new schedule by randomly swapping two tasks in the given schedule.

        Args:
            schedule (list): The current schedule, represented as a list of task IDs in the order they should be executed.
            task_list (list): A list of tasks, where each task is represented as a tuple (p, d), where p is the processing time and d is the deadline.

        Returns:
            A new schedule, generated by randomly swapping two tasks in the given schedule.
        """
        new_schedule = schedule.copy()
        i, j = random.sample(range(len(schedule)), 2)
        new_schedule[i], new_schedule[j] = new_schedule[j], new_schedule[i]
        return new_schedule

    def run(self, task_list):
        n_tasks = len(task_list)
        schedule = list(range(n_tasks))

        best_schedule = schedule.copy()
        best_cost = self.calculate_cost(schedule, task_list)

        for i in range(self.n_iters):
            # Employed bees phase
            for j in range(self.n_employed_bees):
                new_schedule = self.crossover(schedule, task_list)
                new_cost = self.calculate_cost(new_schedule, task_list)
                if new_cost < best_cost:
                    best_schedule = new_schedule.copy()
                    best_cost = new_cost
                if new_cost < self.calculate_cost(schedule, task_list):
                    schedule = new_schedule.copy()

            # Onlooker bees phase
            for j in range(self.n_onlooker_bees):
                bee_schedule = self.crossover(schedule, task_list)
                bee_cost = self.calculate_cost(bee_schedule, task_list)
                if random.uniform(0, 1) < (best_cost - bee_cost) / best_cost:
                    if bee_cost < best_cost:
                        best_schedule = bee_schedule.copy()
                        best_cost = bee_cost
                    if bee_cost < self.calculate_cost(schedule, task_list):
                        schedule = bee_schedule.copy()

            # Scout bees phase
            if random.uniform(0, 1) < 0.1:
                schedule = list(range(n_tasks))

        return best_schedule
