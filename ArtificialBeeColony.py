import random

from FitnessFunctions import min_completion_latency
from Scheduler import Scheduler


class ABC_Scheduler:
    """
    A class representing the ABC algorithm for task scheduling.
    """

    def __init__(self, n_tasks, n_employed_bees, n_onlooker_bees, n_scout_bees, n_iters):
        self.n_tasks = n_tasks
        self.n_employed_bees = n_employed_bees
        self.n_onlooker_bees = n_onlooker_bees
        self.n_scout_bees = n_scout_bees
        self.n_iters = n_iters

    def calculate_cost(self, schedule, task_list):
        return min_completion_latency(schedule,task_list)

    def crossover(self, schedule, task_list):
        """ Generate a new schedule by randomly swapping two tasks in the given schedule.

        Args:
            schedule (list): The current schedule, represented as a list of task IDs in the order they should be executed.
            task_list (list): A list of tasks, where each task is represented as a tuple (p, d), where p is the processing time and d is the deadline.

        Returns:
            A new schedule, generated by randomly swapping two tasks in the given schedule.
        """
        new_schedule = schedule.copy()
        i, j = random.sample(range(len(schedule)), 2)
        new_schedule[i], new_schedule[j] = new_schedule[j], new_schedule[i]
        return new_schedule

    def run(self, task_list):
        n_tasks = len(task_list)
        schedule = list(range(n_tasks))

        best_schedule = schedule.copy()
        best_cost = self.calculate_cost(schedule, task_list)

        for i in range(self.n_iters):
            # Employed bees phase
            for j in range(self.n_employed_bees):
                new_schedule = self.crossover(schedule, task_list)
                new_cost = self.calculate_cost(new_schedule, task_list)
                if new_cost < best_cost:
                    best_schedule = new_schedule.copy()
                    best_cost = new_cost
                if new_cost < self.calculate_cost(schedule, task_list):
                    schedule = new_schedule.copy()

            # Onlooker bees phase
            for j in range(self.n_onlooker_bees):
                bee_schedule = self.crossover(schedule, task_list)
                bee_cost = self.calculate_cost(bee_schedule, task_list)
                if random.uniform(0, 1) < (best_cost - bee_cost) / best_cost:
                    if bee_cost < best_cost:
                        best_schedule = bee_schedule.copy()
                        best_cost = bee_cost
                    if bee_cost < self.calculate_cost(schedule, task_list):
                        schedule = bee_schedule.copy()

            # Scout bees phase
            if random.uniform(0, 1) < 0.1:
                schedule = list(range(n_tasks))

        return best_schedule
